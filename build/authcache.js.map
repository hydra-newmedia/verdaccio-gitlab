{"version":3,"sources":["../src/authcache.js"],"names":["AuthCache","DEFAULT_TTL","_generateKeyHash","username","password","sha","Crypto","createHash","update","JSON","stringify","digest","constructor","logger","ttl","storage","NodeCache","stdTTL","useClones","on","key","value","trace","findUser","get","storeUser","userData","set","UserData","_username","groups","_groups"],"mappings":";;;;;;;AAMA;;;;AACA;;;;;;AAEO,MAAMA,SAAN,CAAgB;;AAKrB,aAAWC,WAAX,GAAyB;AAAE,WAAO,GAAP;AAAa;;AAExC,SAAOC,gBAAP,CAAwBC,QAAxB,EAA0CC,QAA1C,EAA4D;AAC1D,UAAMC,MAAMC,iBAAOC,UAAP,CAAkB,QAAlB,CAAZ;AACAF,QAAIG,MAAJ,CAAWC,KAAKC,SAAL,CAAe,EAAEP,UAAUA,QAAZ,EAAsBC,UAAUA,QAAhC,EAAf,CAAX;AACA,WAAOC,IAAIM,MAAJ,CAAW,KAAX,CAAP;AACD;;AAEDC,cAAYC,MAAZ,EAA4BC,GAA5B,EAA0C;AACxC,SAAKD,MAAL,GAAcA,MAAd;AACA,SAAKC,GAAL,GAAWA,OAAOd,UAAUC,WAA5B;;AAEA,SAAKc,OAAL,GAAe,IAAIC,mBAAJ,CAAc;AAC3BC,cAAQ,KAAKH,GADc;AAE3BI,iBAAW;AAFgB,KAAd,CAAf;AAIA,SAAKH,OAAL,CAAaI,EAAb,CAAgB,SAAhB,EAA2B,CAACC,GAAD,EAAMC,KAAN,KAAgB;AACzC,UAAI,KAAKR,MAAL,CAAYS,KAAZ,EAAJ,EAAyB;AACvB,aAAKT,MAAL,CAAYS,KAAZ,CAAmB,yBAAwBF,GAAI,cAA/C,EAA8DC,KAA9D;AACD;AACF,KAJD;AAKD;;AAEDE,WAASpB,QAAT,EAA2BC,QAA3B,EAAuD;AACrD,WAAO,KAAKW,OAAL,CAAaS,GAAb,CAAiBxB,UAAUE,gBAAV,CAA2BC,QAA3B,EAAqCC,QAArC,CAAjB,CAAP;AACD;;AAEDqB,YAAUtB,QAAV,EAA4BC,QAA5B,EAA8CsB,QAA9C,EAA2E;AACzE,WAAO,KAAKX,OAAL,CAAaY,GAAb,CAAiB3B,UAAUE,gBAAV,CAA2BC,QAA3B,EAAqCC,QAArC,CAAjB,EAAiEsB,QAAjE,CAAP;AACD;AAlCoB;;QAAV1B,S,GAAAA,S,EATb;AACA;;AAiDO,MAAM4B,QAAN,CAAe;;AAIpB,MAAIzB,QAAJ,GAAuB;AAAE,WAAO,KAAK0B,SAAZ;AAAwB;AACjD,MAAIC,MAAJ,GAA6B;AAAE,WAAO,KAAKC,OAAZ;AAAsB;AACrD,MAAID,MAAJ,CAAWA,MAAX,EAAmC;AAAE,SAAKC,OAAL,GAAeD,MAAf;AAAwB;;AAE7DlB,cAAYT,QAAZ,EAA8B2B,MAA9B,EAAsD;AACpD,SAAKD,SAAL,GAAiB1B,QAAjB;AACA,SAAK4B,OAAL,GAAeD,MAAf;AACD;AAXmB;QAATF,Q,GAAAA,Q","file":"authcache.js","sourcesContent":["// Copyright 2018 Roger Meier <roger@bufferoverflow.ch>\n// SPDX-License-Identifier: MIT\n// @flow\n\nimport type { Logger } from '@verdaccio/types';\n\nimport Crypto from 'crypto';\nimport NodeCache from 'node-cache';\n\nexport class AuthCache {\n  logger: Logger;\n  ttl: number;\n  storage: NodeCache;\n\n  static get DEFAULT_TTL() { return 300; }\n\n  static _generateKeyHash(username: string, password: string) {\n    const sha = Crypto.createHash('sha256');\n    sha.update(JSON.stringify({ username: username, password: password }));\n    return sha.digest('hex');\n  }\n\n  constructor(logger: Logger, ttl?: number) {\n    this.logger = logger;\n    this.ttl = ttl || AuthCache.DEFAULT_TTL;\n\n    this.storage = new NodeCache({\n      stdTTL: this.ttl,\n      useClones: false\n    });\n    this.storage.on('expired', (key, value) => {\n      if (this.logger.trace()) {\n        this.logger.trace(`[gitlab] expired key: ${key} with value:`, value);\n      }\n    });\n  }\n\n  findUser(username: string, password: string): UserData {\n    return this.storage.get(AuthCache._generateKeyHash(username, password));\n  }\n\n  storeUser(username: string, password: string, userData: UserData): boolean {\n    return this.storage.set(AuthCache._generateKeyHash(username, password), userData);\n  }\n}\n\nexport type UserDataGroups = {\n  publish: string[]\n};\n\nexport class UserData {\n  _username: string;\n  _groups: UserDataGroups;\n\n  get username(): string { return this._username; }\n  get groups(): UserDataGroups { return this._groups; }\n  set groups(groups: UserDataGroups) { this._groups = groups; }\n\n  constructor(username: string, groups: UserDataGroups) {\n    this._username = username;\n    this._groups = groups;\n  }\n}\n"]}